(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{214:function(t,s,a){"use strict";a.r(s);var n=a(6),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"详解-go-的类型内嵌"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#详解-go-的类型内嵌"}},[t._v("#")]),t._v(" 详解 Go 的类型内嵌")]),t._v(" "),a("p",[t._v("类型内嵌（type embedding） 是 go 语言实现 OOP （Object Orientd Programing）原理的重要特性。本文是 "),a("a",{attrs:{href:"https://go101.org/article/type-embedding.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Type Embedding"),a("OutboundLink")],1),t._v(" 的译文。国内很少资料有如此详细的介绍 golang 的类型内嵌机制，看完后觉得受益匪浅。")]),t._v(" "),a("p",[t._v("Go 的结构体类型可以包含很多个字段，每个字段是由一个字段名称和一个字段值的类型构成的。事实上，一个结构体字段还能只包含一个字段名称，这种声明结构体字段的方式被称为类型内嵌。本文将详细的解释类型内嵌这种机制的目的和详细的使用方式。")]),t._v(" "),a("h2",{attrs:{id:"类型内嵌是什么样的？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类型内嵌是什么样的？"}},[t._v("#")]),t._v(" 类型内嵌是什么样的？")]),t._v(" "),a("p",[t._v("下面是一个例子用来展示类型内嵌：")]),t._v(" "),a("div",{staticClass:"language-go line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),t._v(" main\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"net/http"')]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" P "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("bool")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" M "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("map")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// a defined non-pointer type")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("error")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// a defined interface type")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// a non-defined pointer type")]),t._v("\n\t\tP      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// an alias of a non-defined pointer type")]),t._v("\n\t\tM      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// an alias of a non-defined type")]),t._v("\n\n\t\thttp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Header "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// a defined map type")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\tx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Go"')]),t._v("\n\tx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("error")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("nil")]),t._v("\n\tx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("new")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\tx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("P "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("new")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("bool")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\tx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("M "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("make")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("M"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\tx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Header "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" http"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Header"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br"),a("span",{staticClass:"line-number"},[t._v("16")]),a("br"),a("span",{staticClass:"line-number"},[t._v("17")]),a("br"),a("span",{staticClass:"line-number"},[t._v("18")]),a("br"),a("span",{staticClass:"line-number"},[t._v("19")]),a("br"),a("span",{staticClass:"line-number"},[t._v("20")]),a("br"),a("span",{staticClass:"line-number"},[t._v("21")]),a("br"),a("span",{staticClass:"line-number"},[t._v("22")]),a("br"),a("span",{staticClass:"line-number"},[t._v("23")]),a("br")])]),a("p",[t._v("在上面的例子中，在 x 结构体中一共有 6 种类型被内嵌进去，每种类型的嵌入都形成了一个嵌入式字段。")]),t._v(" "),a("p",[t._v("嵌入的字段也被称为匿名字段。但是每个被嵌入的字段都会有一个指定的字段名称。一般是由嵌入字段的非限定类型名称充当字段名字。例如，上面六种嵌入字段的字段名称分别为 "),a("code",[t._v("string")]),t._v(", "),a("code",[t._v("error")]),t._v(", "),a("code",[t._v("int")]),t._v(", "),a("code",[t._v("P")]),t._v(", "),a("code",[t._v("M")]),t._v(" 和 "),a("code",[t._v("Header")]),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"哪些类型可以被内嵌？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#哪些类型可以被内嵌？"}},[t._v("#")]),t._v(" 哪些类型可以被内嵌？")]),t._v(" "),a("p",[t._v("在官方的 Go 规范文档（go1.14）中是这样描述的：")]),t._v(" "),a("blockquote",[a("p",[t._v("An embedded field must be specified as a type name T or as a pointer to a non-interface type name *T, and T itself may not be a pointer type.")])]),t._v(" "),a("p",[t._v("中文翻译就是一个内嵌的字段必须是一个被声明为类型 "),a("code",[t._v("T")]),t._v(" 或者一个非接口类型的指针类型 "),a("code",[t._v("*T")]),t._v("，其中 "),a("code",[t._v("T")]),t._v(" 是类型名，并且 "),a("code",[t._v("T")]),t._v(" 本身不是一个指针类型 。这个描述在 Go 1.9 之前是完全正确的，但是现在显得有些过时和不太准确了。比如上面那个例子中，这个描述没有包括对 "),a("code",[t._v("类型别名 P")]),t._v(" 这种情况的涵盖。这里，本文试图使用一个更精确的描述：")]),t._v(" "),a("ul",[a("li",[t._v("一个类型名 "),a("code",[t._v("T")]),t._v(" 能够被内嵌并作为一个内嵌字段，除非 "),a("code",[t._v("T")]),t._v(" 代表了一个已定义的指针类型或者一个基类型是指针或者接口类型的指针类型")]),t._v(" "),a("li")])])}),[],!1,null,null,null);s.default=e.exports}}]);