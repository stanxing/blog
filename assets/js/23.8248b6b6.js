(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{205:function(s,e,a){"use strict";a.r(e);var t=a(6),n=Object(t.a)({},(function(){var s=this,e=s.$createElement,a=s._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"dockerfile-最佳实践"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dockerfile-最佳实践"}},[s._v("#")]),s._v(" Dockerfile 最佳实践")]),s._v(" "),a("h2",{attrs:{id:"entrypoint-vs-cmd"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entrypoint-vs-cmd"}},[s._v("#")]),s._v(" ENTRYPOINT vs CMD")]),s._v(" "),a("p",[s._v("ENTRYPOINT 和 CMD 都用来指定一个可执行程序，这个可执行程序在 container 启动后自动运行。如果想要让自己制作的镜像自动运行程序（不需要在 docker run 后面添加命令），就需要使用这两个命令。")]),s._v(" "),a("p",[s._v("大部分基础镜像例如 "),a("code",[s._v("ubuntu")]),s._v(" 等都内置了 CMD 指令，一般是 "),a("code",[s._v("CMD /bin/bash")]),s._v(" 或者 "),a("code",[s._v("CMD /bin/sh")]),s._v(" 等。")]),s._v(" "),a("p",[s._v("在基于基础镜像构建新的镜像的时候，只要在 Dockerfile 里指定这两个命令就能覆盖掉原镜像中的命令。")]),s._v(" "),a("h3",{attrs:{id:"cmd"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cmd"}},[s._v("#")]),s._v(" CMD")]),s._v(" "),a("p",[s._v("CMD 有三种形式：")]),s._v(" "),a("ul",[a("li",[s._v("exec 形式，必须是一个JSON Array 的格式：")])]),s._v(" "),a("div",{staticClass:"language-dockerfile line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" ubuntu"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("14.04\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("CMD")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"ping"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"localhost"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("ul",[a("li",[s._v("若 "),a("code",[s._v("ENTRYPOINT")]),s._v(" 存在，作为其默认参数，必须是一个JSON Array 的格式：")])]),s._v(" "),a("div",{staticClass:"language-dockerfile line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" ubuntu"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("14.04\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("ENTRYPOINT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"ping"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"localhost"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("CMD")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"-c"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"3"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("ul",[a("li",[s._v("shell 形式：")])]),s._v(" "),a("div",{staticClass:"language-dockerfile line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" ubuntu"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("14.04\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("CMD")]),s._v(" ping localhost\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("shell 形式在容器启动执行命令时会自动在指令前拼接 "),a("code",[s._v("/bin/sh -c")]),s._v("，也就是 sh 进程会作为容器的 PID 1 进程。而 exec 进程它还会将用户指定的进程作为容器内的 PID 1 进程运行，这样方便传递信号给该进程。所以再编写 Dockerfile 文件时优先使用 exec 模式。")]),s._v(" "),a("p",[s._v("CMD 命令可以被 "),a("code",[s._v("docker run image")]),s._v(" 后面的命令行参数替换掉：")]),s._v(" "),a("ul",[a("li",[s._v("对于没有 "),a("code",[s._v("ENTRYPOINT")]),s._v(" 的情况，比如执行 "),a("code",[s._v("docker run demo ls")]),s._v("，将忽略原有的 CMD 命令执行 "),a("code",[s._v("ls")]),s._v(" 列出容器内的目录。")]),s._v(" "),a("li",[s._v("对于包含了 "),a("code",[s._v("ENTRYPOINT")]),s._v(" 的情况，"),a("code",[s._v("docker run demo")]),s._v(" 后面的参数将作为 "),a("code",[s._v("ENTRYPOINT")]),s._v(" 的参数覆盖掉默认的 CMD 中的默认参数。")]),s._v(" "),a("li",[s._v("注意，包含了 "),a("code",[s._v("ENTRYPOINT")]),s._v(" 后，CMD 不能是一个 shell 形式，否则会自动拼接上 "),a("code",[s._v("/bin/sh -c")]),s._v(" 传给 "),a("code",[s._v("ENTRYPOINT")]),s._v("，显然是不对的。")])]),s._v(" "),a("h3",{attrs:{id:"entrypoint"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entrypoint"}},[s._v("#")]),s._v(" ENTRYPOINT")]),s._v(" "),a("p",[s._v("ENTRYPOINT 指令有两种形式：")]),s._v(" "),a("ul",[a("li",[s._v("exec 模式：")])]),s._v(" "),a("div",{staticClass:"language-dockerfile line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" ubuntu"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("14.04\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("ENTRYPOINT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"ping"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"localhost"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("以这种模式定义的镜像在容器启动时会自动执行 "),a("code",[s._v("ENTRYPOINT")]),s._v(" 指令，并且会将 "),a("code",[s._v("docker run image")]),s._v(" 后的命令行参数附加在 "),a("code",[s._v("ENTRYPOINT")]),s._v(" 的指令之后，例如 "),a("code",[s._v("docker run demo -c 3")]),s._v("，容器内实际执行的指令就是 "),a("code",[s._v("ping localhost -c 3")]),s._v("。如果需要在命令行覆盖 "),a("code",[s._v("ENTRYPOINT")]),s._v(" 指令，可以使用 "),a("code",[s._v("docker run --entrypoint")]),s._v(" 选项。")]),s._v(" "),a("ul",[a("li",[s._v("shell 模式：")])]),s._v(" "),a("div",{staticClass:"language-dockerfile line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" ubuntu"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("14.04\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("ENTRYPOINT")]),s._v(" ping localhost\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("h3",{attrs:{id:"注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[s._v("#")]),s._v(" 注意事项")]),s._v(" "),a("ul",[a("li",[s._v("基础镜像里指定了 "),a("code",[s._v("CMD")]),s._v(" 指令，新镜像基于该镜像构建，并且重新指定了 "),a("code",[s._v("ENTRYPOINT")]),s._v("，此时，基础镜像里的 "),a("code",[s._v("CMD")]),s._v(" 指令会失效，以 "),a("code",[s._v("ENTRYPOINT")]),s._v(" 为准。")]),s._v(" "),a("li",[s._v("基础镜像里指定了 "),a("code",[s._v("ENTRYPOINT")]),s._v(" 指令，新镜像基于该镜像构建，并且重新指定了 "),a("code",[s._v("CMD")]),s._v("，此时，此时新镜像执行的命令依旧以 "),a("code",[s._v("ENTRYPOINT")]),s._v(" 为准，"),a("code",[s._v("CMD")]),s._v(" 作为参数传入。")])]),s._v(" "),a("h3",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[s._v("#")]),s._v(" 参考")]),s._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://docs.docker.com/engine/reference/builder/#cmd",target:"_blank",rel:"noopener noreferrer"}},[s._v("CMD"),a("OutboundLink")],1)]),s._v(" "),a("li",[a("a",{attrs:{href:"https://docs.docker.com/engine/reference/builder/#entrypoint",target:"_blank",rel:"noopener noreferrer"}},[s._v("ENTRYPOINT"),a("OutboundLink")],1)]),s._v(" "),a("li",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/30555962",target:"_blank",rel:"noopener noreferrer"}},[s._v("Dockerfile: ENTRYPOINT和CMD的区别"),a("OutboundLink")],1)])]),s._v(" "),a("h2",{attrs:{id:"add-vs-copy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#add-vs-copy"}},[s._v("#")]),s._v(" ADD vs COPY")]),s._v(" "),a("h3",{attrs:{id:"add"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#add"}},[s._v("#")]),s._v(" ADD")]),s._v(" "),a("ul",[a("li",[a("p",[a("code",[s._v("ADD")]),s._v(" 允许使用一个 URL 作为 "),a("code",[s._v("src")]),s._v(" 参数，例如：")]),s._v(" "),a("ul",[a("li",[a("code",[s._v("ADD http://foo.com/bar.go /tmp/main.go")]),s._v("，这句指令将从远程下载 "),a("code",[s._v("bar.go")]),s._v(" 文件，并拷贝成 "),a("code",[s._v("/tmp/main.go")]),s._v("。")]),s._v(" "),a("li",[a("code",[s._v("ADD http://foo.com/bar.go /tmp/")]),s._v("，这句指令将从远程下载 "),a("code",[s._v("bar.go")]),s._v(" 指令，并拷贝到 "),a("code",[s._v("/tmp/")]),s._v(" 目录下（文件名仍然是 "),a("code",[s._v("bar.go")]),s._v("）。Docker 会自动根据 "),a("code",[s._v("dst")]),s._v(" 的结尾是不是斜杠来推断拷贝到一个目录还是文件。")])])]),s._v(" "),a("li",[a("p",[a("code",[s._v("ADD")]),s._v(" 允许自动解压被压缩的文件，如果 "),a("code",[s._v("src")]),s._v(" 是一个被压缩的格式，比如 "),a("code",[s._v("tar")]),s._v("，"),a("code",[s._v("gzip")]),s._v("，"),a("code",[s._v("bzip2")]),s._v(" 等，将自动解压到 "),a("code",[s._v("dst")]),s._v(" 目录下。")]),s._v(" "),a("ul",[a("li",[a("code",[s._v("ADD /foo.tar.gz /tmp/")]),s._v("，这句将解压 "),a("code",[s._v("foo.tar.gz")]),s._v(" 到 "),a("code",[s._v("/tmp")]),s._v(" 目录下。")])])]),s._v(" "),a("li",[a("p",[s._v("值得注意的是，"),a("code",[s._v("ADD")]),s._v(" 的从 URL 下载文件 和解压缩两个特性不能同时使用，如果从远程下载一个压缩文件，"),a("code",[s._v("ADD")]),s._v(" 不会解压，只会直接拷贝。")])])]),s._v(" "),a("h3",{attrs:{id:"copy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copy"}},[s._v("#")]),s._v(" COPY")]),s._v(" "),a("ul",[a("li",[s._v("由于 "),a("code",[s._v("ADD")]),s._v(" 功能的复杂性（做了太多事情）和行为的不可预测性，docker 增加了 "),a("code",[s._v("COPY")]),s._v(" 命令，"),a("code",[s._v("COPY")]),s._v(" 不支持上面 "),a("code",[s._v("ADD")]),s._v(" 的那些功能，仅仅用来实现本地文件或者目录的拷贝。")]),s._v(" "),a("li",[s._v("在多阶段构建功能出现后，"),a("code",[s._v("COPY")]),s._v(" 又增加了一个功能是从构建镜像中拷贝文件到新镜像中。")])]),s._v(" "),a("h3",{attrs:{id:"使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[s._v("#")]),s._v(" 使用场景")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("本地拷贝文件的场景都应该使用 "),a("code",[s._v("COPY")]),s._v("。")])]),s._v(" "),a("li",[a("p",[s._v("需要自动解压的场景可以选择 "),a("code",[s._v("ADD")]),s._v("。")])]),s._v(" "),a("li",[a("p",[s._v("从远程 URL 下载文件也不应该使用 "),a("code",[s._v("ADD")]),s._v("，例如下面的例子："),a("br"),s._v("\n这样会使用两条指令，一条下载，一条解压安装并清理无用文件。看起来没啥问题，但实际上这样做并不会减少镜像的大小，因为 "),a("code",[s._v("rm")]),s._v(" 操作在单独的镜像层。")]),s._v(" "),a("div",{staticClass:"language-dockerfile line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("ADD")]),s._v(" http"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("//foo.com/package.tar.bz2 /tmp/\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("RUN")]),s._v(" tar "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("xjf /tmp/package.tar.bz2 \\\n    && make "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("C /tmp/package \\\n    && rm /tmp/package.tar.bz2\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("更好的做法是，将整个操作写在一行，这样只会在同一个镜像层处理。")]),s._v(" "),a("div",{staticClass:"language-dockerfile line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("RUN")]),s._v(" curl http"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("//foo.com/package.tar.bz2 \\\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("|")]),s._v(" tar "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("xjC /tmp/package \\\n    && make "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("C /tmp/package\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])])])]),s._v(" "),a("h3",{attrs:{id:"参考-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考-2"}},[s._v("#")]),s._v(" 参考")]),s._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://www.ctl.io/developers/blog/post/dockerfile-add-vs-copy/",target:"_blank",rel:"noopener noreferrer"}},[s._v("copy vs add"),a("OutboundLink")],1)])]),s._v(" "),a("h2",{attrs:{id:"编写-dockerfile-的最佳实践"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编写-dockerfile-的最佳实践"}},[s._v("#")]),s._v(" 编写 Dockerfile 的最佳实践")]),s._v(" "),a("h3",{attrs:{id:"使用-dockerignore"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-dockerignore"}},[s._v("#")]),s._v(" 使用 .dockerignore")]),s._v(" "),a("p",[a("code",[s._v(".dockerignore")]),s._v(" 文件可以用来排除那些不需要在构建镜像中复制的文件，类似于 "),a("code",[s._v(".gitignore")]),s._v("。")]),s._v(" "),a("h3",{attrs:{id:"使用-multi-stage-构建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-multi-stage-构建"}},[s._v("#")]),s._v(" 使用 multi-stage 构建")]),s._v(" "),a("p",[s._v("对于 go，c 这种编译型语言，使用多阶段构建可以显著的减少最终生成的镜像的体积。下面是一个多阶段构建的例子，通过使用 COPY 命令从 build 镜像中拷贝编译好的二进制文件到一个崭新的基础镜像中运行，可以直接越过中间的各种编译的层，减少镜像的体积。")]),s._v(" "),a("div",{staticClass:"language-dockerfile line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" golang"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("1.11"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("alpine AS build\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# Install tools required for project")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# Run `docker build --no-cache .` to update dependencies")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("RUN")]),s._v(" apk add "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("no"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("cache git\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("RUN")]),s._v(" go get github.com/golang/dep/cmd/dep\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# List project dependencies with Gopkg.toml and Gopkg.lock")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# These layers are only re-built when Gopkg files are updated")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("COPY")]),s._v(" Gopkg.lock Gopkg.toml /go/src/project/\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WORKDIR")]),s._v(" /go/src/project/\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# Install library dependencies")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("RUN")]),s._v(" dep ensure "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("vendor"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("only\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# Copy the entire project and build it")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# This layer is rebuilt when a file changes in the project directory")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("COPY")]),s._v(" . /go/src/project/\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("RUN")]),s._v(" go build "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("o /bin/project\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# This results in a single layer image")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" scratch\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("COPY")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("from=build /bin/project /bin/project\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("ENTRYPOINT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"/bin/project"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("CMD")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"--help"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br")])]),a("h3",{attrs:{id:"不要安装不必要的包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不要安装不必要的包"}},[s._v("#")]),s._v(" 不要安装不必要的包")]),s._v(" "),a("h3",{attrs:{id:"解耦应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解耦应用"}},[s._v("#")]),s._v(" 解耦应用")]),s._v(" "),a("p",[s._v("一个 docker 容器不应该做太多的事，可以使用多个 docker 容器来分别部署不相关的应用，让他们通过容器网络来交互。")]),s._v(" "),a("h3",{attrs:{id:"对多行参数排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对多行参数排序"}},[s._v("#")]),s._v(" 对多行参数排序")]),s._v(" "),a("p",[s._v("举例如下，多个包的名字应该通过 "),a("code",[s._v("\\")]),s._v(" 来换行，并且和包名称前空一个空格，使得结构看起来更加清晰。")]),s._v(" "),a("div",{staticClass:"language-dockerfile line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("RUN")]),s._v(" apt"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("get update && apt"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("get install "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("y \\\n  bzr \\\n  cvs \\\n  git \\\n  mercurial \\\n  subversion\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("h3",{attrs:{id:"利用构建缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#利用构建缓存"}},[s._v("#")]),s._v(" 利用构建缓存")]),s._v(" "),a("p",[s._v("Dockerfile 在构建时按照其中的指令顺序构建，每次构建都会生成一个中间镜像。下一条指令会根据上一个中间镜像的结果来构建。所以每次检查指令的时候， docker 会寻找是否有镜像缓存可以复用，这样就不需要创建一个新的中间镜像。如果不想使用缓存，可以在构建的时候使用 "),a("code",[s._v("--no-cache")]),s._v("。")]),s._v(" "),a("p",[s._v("docker daemnon 通过 Dockerfile 构建镜像时，当发现即将新构建出的镜像与已有的某镜像重复时，可以选择放弃构建新的镜像，而是选用已有的镜像作为构建结果，也就是采取本地已经 cache 的镜像作为结果。")]),s._v(" "),a("p",[s._v("缓存的命中规则如下：")]),s._v(" "),a("ul",[a("li",[s._v("基本原则是从已在缓存中的父镜像开始，将下一条指令与从该基本镜像派生的所有子映像进行比较，以查看是否其中一个是使用完全相同的指令构建的。如果不是，则缓存无效。")]),s._v(" "),a("li",[s._v("对于 "),a("code",[s._v("ADD")]),s._v(" 和 "),a("code",[s._v("COPY")]),s._v(" 指令，镜像中文件的内容被检查，然后对每个文件计算一个校验和，校验和中不关注上次修改时间和上次访问时间。在检查缓存的时候，将校验和和已有的镜像做比较，如果相等，则使用缓存，如果不相等，该镜像及后续所有的构建缓存全部无效。")]),s._v(" "),a("li",[s._v("除却这两个命令的其他命令，缓存都不会通过检查文件来确定缓存是否改变。举个例子，"),a("code",[s._v("RUN apt-get -y update")]),s._v(" 这个指令不会通过比较文件变化来确定缓存，仅仅通过比较指令的字符串有没有发生变化来确定是否使用缓存。")]),s._v(" "),a("li",[s._v("一旦缓存无效，dockerfile 中后续所有的指令都会生成新的镜像来构建。")])]),s._v(" "),a("h4",{attrs:{id:"利用缓存的最佳实践"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#利用缓存的最佳实践"}},[s._v("#")]),s._v(" 利用缓存的最佳实践")]),s._v(" "),a("p",[s._v("由于 docker 缓存的机制，要将不长变更的改动放在 Dockerfile 的最前面，比如 "),a("code",[s._v("RUN apt update")]),s._v(" 或者 "),a("code",[s._v("RUN curl xxx")]),s._v(" 等，同时，针对不同语言，例如 nodejs，应该将 package.json 文件先拷贝进来再执行 "),a("code",[s._v("npm install")]),s._v("，这样当 nodejs 里其他文件变更并不会导致 "),a("code",[s._v("npm install")]),s._v(" 的执行，从而加快构建。对于 golang 来说，同样的道理，应该先拷贝 "),a("code",[s._v("go.mod")]),s._v(" 和 "),a("code",[s._v("go.sum")]),s._v("，再执行 "),a("code",[s._v("go mod download")]),s._v(", 这样可以有效的缓存安装的依赖，加快构建。")]),s._v(" "),a("h3",{attrs:{id:"不要在-dockerfile-中映射公有端口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不要在-dockerfile-中映射公有端口"}},[s._v("#")]),s._v(" 不要在 Dockerfile 中映射公有端口")]),s._v(" "),a("p",[s._v("例如下面这种，这样会给应用的部署带来不确定性，应该通过 -p 来在运行时指定。")]),s._v(" "),a("div",{staticClass:"language-dockerfile line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[a("code",[s._v("＃private and public mapping\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("EXPOSE")]),s._v(" 80"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("8080\n\n＃private only\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("EXPOSE")]),s._v(" 80\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("h3",{attrs:{id:"尽量减少镜像大小"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#尽量减少镜像大小"}},[s._v("#")]),s._v(" 尽量减少镜像大小")]),s._v(" "),a("h3",{attrs:{id:"参考-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考-3"}},[s._v("#")]),s._v(" 参考")]),s._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://docs.docker.com/develop/develop-images/dockerfile_best-practices/",target:"_blank",rel:"noopener noreferrer"}},[s._v("dockerfile-best-practices"),a("OutboundLink")],1)]),s._v(" "),a("li",[a("a",{attrs:{href:"http://open.daocloud.io/docker-build-de-cache-ji-zhi/",target:"_blank",rel:"noopener noreferrer"}},[s._v("docker cache 机制"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=n.exports}}]);