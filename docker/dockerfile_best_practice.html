<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Dockerfile 最佳实践 | Stan Xing 的个人博客</title>
    <meta name="generator" content="VuePress 1.4.1">
    
    <meta name="description" content="记录自己的技术成长">
    <link rel="preload" href="/blog/assets/css/0.styles.eb3efacf.css" as="style"><link rel="preload" href="/blog/assets/js/app.2efd3993.js" as="script"><link rel="preload" href="/blog/assets/js/2.371adafa.js" as="script"><link rel="preload" href="/blog/assets/js/23.8248b6b6.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.76044a89.js"><link rel="prefetch" href="/blog/assets/js/11.16dcfdf2.js"><link rel="prefetch" href="/blog/assets/js/12.567cf3a1.js"><link rel="prefetch" href="/blog/assets/js/13.fc698a2f.js"><link rel="prefetch" href="/blog/assets/js/14.120e22bc.js"><link rel="prefetch" href="/blog/assets/js/15.31517948.js"><link rel="prefetch" href="/blog/assets/js/16.f2796001.js"><link rel="prefetch" href="/blog/assets/js/17.74fd029d.js"><link rel="prefetch" href="/blog/assets/js/18.ea9c27da.js"><link rel="prefetch" href="/blog/assets/js/19.c5d2f40c.js"><link rel="prefetch" href="/blog/assets/js/20.b55c339f.js"><link rel="prefetch" href="/blog/assets/js/21.95249f05.js"><link rel="prefetch" href="/blog/assets/js/22.965e5f58.js"><link rel="prefetch" href="/blog/assets/js/24.fe6aef0a.js"><link rel="prefetch" href="/blog/assets/js/25.ef479bf5.js"><link rel="prefetch" href="/blog/assets/js/26.b745054e.js"><link rel="prefetch" href="/blog/assets/js/27.e9839df3.js"><link rel="prefetch" href="/blog/assets/js/28.796bfa26.js"><link rel="prefetch" href="/blog/assets/js/29.38b104b6.js"><link rel="prefetch" href="/blog/assets/js/3.159d2146.js"><link rel="prefetch" href="/blog/assets/js/30.4af86574.js"><link rel="prefetch" href="/blog/assets/js/31.90b14a89.js"><link rel="prefetch" href="/blog/assets/js/32.b471f649.js"><link rel="prefetch" href="/blog/assets/js/33.d8e805f8.js"><link rel="prefetch" href="/blog/assets/js/34.09a753bf.js"><link rel="prefetch" href="/blog/assets/js/35.3fee7620.js"><link rel="prefetch" href="/blog/assets/js/36.03747912.js"><link rel="prefetch" href="/blog/assets/js/37.554dda8c.js"><link rel="prefetch" href="/blog/assets/js/38.46bcde33.js"><link rel="prefetch" href="/blog/assets/js/39.a82e6ea2.js"><link rel="prefetch" href="/blog/assets/js/4.8ed88519.js"><link rel="prefetch" href="/blog/assets/js/40.d6208f57.js"><link rel="prefetch" href="/blog/assets/js/41.b7a3a229.js"><link rel="prefetch" href="/blog/assets/js/42.ffb33af9.js"><link rel="prefetch" href="/blog/assets/js/43.c90b42ae.js"><link rel="prefetch" href="/blog/assets/js/44.fe190f21.js"><link rel="prefetch" href="/blog/assets/js/45.a4116688.js"><link rel="prefetch" href="/blog/assets/js/46.395f4bf2.js"><link rel="prefetch" href="/blog/assets/js/47.898431b6.js"><link rel="prefetch" href="/blog/assets/js/48.cb7a367c.js"><link rel="prefetch" href="/blog/assets/js/49.0f5b617e.js"><link rel="prefetch" href="/blog/assets/js/5.26b70a23.js"><link rel="prefetch" href="/blog/assets/js/50.bfaba15c.js"><link rel="prefetch" href="/blog/assets/js/51.604e12fd.js"><link rel="prefetch" href="/blog/assets/js/52.e63c94bd.js"><link rel="prefetch" href="/blog/assets/js/6.169e9be1.js"><link rel="prefetch" href="/blog/assets/js/7.e70cb6ab.js"><link rel="prefetch" href="/blog/assets/js/8.2450bca1.js"><link rel="prefetch" href="/blog/assets/js/9.5476b311.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.eb3efacf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">Stan Xing 的个人博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/blog/" class="sidebar-link">前言</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Algorithms</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTTP</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Golang</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>NodeJS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Docker</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/docker/dockerfile_best_practice.html" class="active sidebar-link">Dockerfile 最佳实践</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/docker/dockerfile_best_practice.html#entrypoint-vs-cmd" class="sidebar-link">ENTRYPOINT vs CMD</a></li><li class="sidebar-sub-header"><a href="/blog/docker/dockerfile_best_practice.html#add-vs-copy" class="sidebar-link">ADD vs COPY</a></li><li class="sidebar-sub-header"><a href="/blog/docker/dockerfile_best_practice.html#编写-dockerfile-的最佳实践" class="sidebar-link">编写 Dockerfile 的最佳实践</a></li></ul></li><li><a href="/blog/docker/command.html" class="sidebar-link">docker 常用命令</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Database</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Infrastructure</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>SRE</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="dockerfile-最佳实践"><a href="#dockerfile-最佳实践" class="header-anchor">#</a> Dockerfile 最佳实践</h1> <h2 id="entrypoint-vs-cmd"><a href="#entrypoint-vs-cmd" class="header-anchor">#</a> ENTRYPOINT vs CMD</h2> <p>ENTRYPOINT 和 CMD 都用来指定一个可执行程序，这个可执行程序在 container 启动后自动运行。如果想要让自己制作的镜像自动运行程序（不需要在 docker run 后面添加命令），就需要使用这两个命令。</p> <p>大部分基础镜像例如 <code>ubuntu</code> 等都内置了 CMD 指令，一般是 <code>CMD /bin/bash</code> 或者 <code>CMD /bin/sh</code> 等。</p> <p>在基于基础镜像构建新的镜像的时候，只要在 Dockerfile 里指定这两个命令就能覆盖掉原镜像中的命令。</p> <h3 id="cmd"><a href="#cmd" class="header-anchor">#</a> CMD</h3> <p>CMD 有三种形式：</p> <ul><li>exec 形式，必须是一个JSON Array 的格式：</li></ul> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token keyword">FROM</span> ubuntu<span class="token punctuation">:</span>14.04
<span class="token keyword">CMD</span> <span class="token punctuation">[</span><span class="token string">&quot;ping&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;localhost&quot;</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>若 <code>ENTRYPOINT</code> 存在，作为其默认参数，必须是一个JSON Array 的格式：</li></ul> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token keyword">FROM</span> ubuntu<span class="token punctuation">:</span>14.04
<span class="token keyword">ENTRYPOINT</span> <span class="token punctuation">[</span><span class="token string">&quot;ping&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;localhost&quot;</span><span class="token punctuation">]</span>
<span class="token keyword">CMD</span> <span class="token punctuation">[</span><span class="token string">&quot;-c&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;3&quot;</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>shell 形式：</li></ul> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token keyword">FROM</span> ubuntu<span class="token punctuation">:</span>14.04
<span class="token keyword">CMD</span> ping localhost
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>shell 形式在容器启动执行命令时会自动在指令前拼接 <code>/bin/sh -c</code>，也就是 sh 进程会作为容器的 PID 1 进程。而 exec 进程它还会将用户指定的进程作为容器内的 PID 1 进程运行，这样方便传递信号给该进程。所以再编写 Dockerfile 文件时优先使用 exec 模式。</p> <p>CMD 命令可以被 <code>docker run image</code> 后面的命令行参数替换掉：</p> <ul><li>对于没有 <code>ENTRYPOINT</code> 的情况，比如执行 <code>docker run demo ls</code>，将忽略原有的 CMD 命令执行 <code>ls</code> 列出容器内的目录。</li> <li>对于包含了 <code>ENTRYPOINT</code> 的情况，<code>docker run demo</code> 后面的参数将作为 <code>ENTRYPOINT</code> 的参数覆盖掉默认的 CMD 中的默认参数。</li> <li>注意，包含了 <code>ENTRYPOINT</code> 后，CMD 不能是一个 shell 形式，否则会自动拼接上 <code>/bin/sh -c</code> 传给 <code>ENTRYPOINT</code>，显然是不对的。</li></ul> <h3 id="entrypoint"><a href="#entrypoint" class="header-anchor">#</a> ENTRYPOINT</h3> <p>ENTRYPOINT 指令有两种形式：</p> <ul><li>exec 模式：</li></ul> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token keyword">FROM</span> ubuntu<span class="token punctuation">:</span>14.04
<span class="token keyword">ENTRYPOINT</span> <span class="token punctuation">[</span><span class="token string">&quot;ping&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;localhost&quot;</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>以这种模式定义的镜像在容器启动时会自动执行 <code>ENTRYPOINT</code> 指令，并且会将 <code>docker run image</code> 后的命令行参数附加在 <code>ENTRYPOINT</code> 的指令之后，例如 <code>docker run demo -c 3</code>，容器内实际执行的指令就是 <code>ping localhost -c 3</code>。如果需要在命令行覆盖 <code>ENTRYPOINT</code> 指令，可以使用 <code>docker run --entrypoint</code> 选项。</p> <ul><li>shell 模式：</li></ul> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token keyword">FROM</span> ubuntu<span class="token punctuation">:</span>14.04
<span class="token keyword">ENTRYPOINT</span> ping localhost
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="注意事项"><a href="#注意事项" class="header-anchor">#</a> 注意事项</h3> <ul><li>基础镜像里指定了 <code>CMD</code> 指令，新镜像基于该镜像构建，并且重新指定了 <code>ENTRYPOINT</code>，此时，基础镜像里的 <code>CMD</code> 指令会失效，以 <code>ENTRYPOINT</code> 为准。</li> <li>基础镜像里指定了 <code>ENTRYPOINT</code> 指令，新镜像基于该镜像构建，并且重新指定了 <code>CMD</code>，此时，此时新镜像执行的命令依旧以 <code>ENTRYPOINT</code> 为准，<code>CMD</code> 作为参数传入。</li></ul> <h3 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h3> <ul><li><a href="https://docs.docker.com/engine/reference/builder/#cmd" target="_blank" rel="noopener noreferrer">CMD<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://docs.docker.com/engine/reference/builder/#entrypoint" target="_blank" rel="noopener noreferrer">ENTRYPOINT<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://zhuanlan.zhihu.com/p/30555962" target="_blank" rel="noopener noreferrer">Dockerfile: ENTRYPOINT和CMD的区别<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="add-vs-copy"><a href="#add-vs-copy" class="header-anchor">#</a> ADD vs COPY</h2> <h3 id="add"><a href="#add" class="header-anchor">#</a> ADD</h3> <ul><li><p><code>ADD</code> 允许使用一个 URL 作为 <code>src</code> 参数，例如：</p> <ul><li><code>ADD http://foo.com/bar.go /tmp/main.go</code>，这句指令将从远程下载 <code>bar.go</code> 文件，并拷贝成 <code>/tmp/main.go</code>。</li> <li><code>ADD http://foo.com/bar.go /tmp/</code>，这句指令将从远程下载 <code>bar.go</code> 指令，并拷贝到 <code>/tmp/</code> 目录下（文件名仍然是 <code>bar.go</code>）。Docker 会自动根据 <code>dst</code> 的结尾是不是斜杠来推断拷贝到一个目录还是文件。</li></ul></li> <li><p><code>ADD</code> 允许自动解压被压缩的文件，如果 <code>src</code> 是一个被压缩的格式，比如 <code>tar</code>，<code>gzip</code>，<code>bzip2</code> 等，将自动解压到 <code>dst</code> 目录下。</p> <ul><li><code>ADD /foo.tar.gz /tmp/</code>，这句将解压 <code>foo.tar.gz</code> 到 <code>/tmp</code> 目录下。</li></ul></li> <li><p>值得注意的是，<code>ADD</code> 的从 URL 下载文件 和解压缩两个特性不能同时使用，如果从远程下载一个压缩文件，<code>ADD</code> 不会解压，只会直接拷贝。</p></li></ul> <h3 id="copy"><a href="#copy" class="header-anchor">#</a> COPY</h3> <ul><li>由于 <code>ADD</code> 功能的复杂性（做了太多事情）和行为的不可预测性，docker 增加了 <code>COPY</code> 命令，<code>COPY</code> 不支持上面 <code>ADD</code> 的那些功能，仅仅用来实现本地文件或者目录的拷贝。</li> <li>在多阶段构建功能出现后，<code>COPY</code> 又增加了一个功能是从构建镜像中拷贝文件到新镜像中。</li></ul> <h3 id="使用场景"><a href="#使用场景" class="header-anchor">#</a> 使用场景</h3> <ul><li><p>本地拷贝文件的场景都应该使用 <code>COPY</code>。</p></li> <li><p>需要自动解压的场景可以选择 <code>ADD</code>。</p></li> <li><p>从远程 URL 下载文件也不应该使用 <code>ADD</code>，例如下面的例子：<br>
这样会使用两条指令，一条下载，一条解压安装并清理无用文件。看起来没啥问题，但实际上这样做并不会减少镜像的大小，因为 <code>rm</code> 操作在单独的镜像层。</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token keyword">ADD</span> http<span class="token punctuation">:</span>//foo.com/package.tar.bz2 /tmp/
<span class="token keyword">RUN</span> tar <span class="token punctuation">-</span>xjf /tmp/package.tar.bz2 \
    &amp;&amp; make <span class="token punctuation">-</span>C /tmp/package \
    &amp;&amp; rm /tmp/package.tar.bz2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>更好的做法是，将整个操作写在一行，这样只会在同一个镜像层处理。</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token keyword">RUN</span> curl http<span class="token punctuation">:</span>//foo.com/package.tar.bz2 \
    <span class="token punctuation">|</span> tar <span class="token punctuation">-</span>xjC /tmp/package \
    &amp;&amp; make <span class="token punctuation">-</span>C /tmp/package
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ul> <h3 id="参考-2"><a href="#参考-2" class="header-anchor">#</a> 参考</h3> <ul><li><a href="https://www.ctl.io/developers/blog/post/dockerfile-add-vs-copy/" target="_blank" rel="noopener noreferrer">copy vs add<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="编写-dockerfile-的最佳实践"><a href="#编写-dockerfile-的最佳实践" class="header-anchor">#</a> 编写 Dockerfile 的最佳实践</h2> <h3 id="使用-dockerignore"><a href="#使用-dockerignore" class="header-anchor">#</a> 使用 .dockerignore</h3> <p><code>.dockerignore</code> 文件可以用来排除那些不需要在构建镜像中复制的文件，类似于 <code>.gitignore</code>。</p> <h3 id="使用-multi-stage-构建"><a href="#使用-multi-stage-构建" class="header-anchor">#</a> 使用 multi-stage 构建</h3> <p>对于 go，c 这种编译型语言，使用多阶段构建可以显著的减少最终生成的镜像的体积。下面是一个多阶段构建的例子，通过使用 COPY 命令从 build 镜像中拷贝编译好的二进制文件到一个崭新的基础镜像中运行，可以直接越过中间的各种编译的层，减少镜像的体积。</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token keyword">FROM</span> golang<span class="token punctuation">:</span>1.11<span class="token punctuation">-</span>alpine AS build

<span class="token comment"># Install tools required for project</span>
<span class="token comment"># Run `docker build --no-cache .` to update dependencies</span>
<span class="token keyword">RUN</span> apk add <span class="token punctuation">-</span><span class="token punctuation">-</span>no<span class="token punctuation">-</span>cache git
<span class="token keyword">RUN</span> go get github.com/golang/dep/cmd/dep

<span class="token comment"># List project dependencies with Gopkg.toml and Gopkg.lock</span>
<span class="token comment"># These layers are only re-built when Gopkg files are updated</span>
<span class="token keyword">COPY</span> Gopkg.lock Gopkg.toml /go/src/project/
<span class="token keyword">WORKDIR</span> /go/src/project/
<span class="token comment"># Install library dependencies</span>
<span class="token keyword">RUN</span> dep ensure <span class="token punctuation">-</span>vendor<span class="token punctuation">-</span>only

<span class="token comment"># Copy the entire project and build it</span>
<span class="token comment"># This layer is rebuilt when a file changes in the project directory</span>
<span class="token keyword">COPY</span> . /go/src/project/
<span class="token keyword">RUN</span> go build <span class="token punctuation">-</span>o /bin/project

<span class="token comment"># This results in a single layer image</span>
<span class="token keyword">FROM</span> scratch
<span class="token keyword">COPY</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>from=build /bin/project /bin/project
<span class="token keyword">ENTRYPOINT</span> <span class="token punctuation">[</span><span class="token string">&quot;/bin/project&quot;</span><span class="token punctuation">]</span>
<span class="token keyword">CMD</span> <span class="token punctuation">[</span><span class="token string">&quot;--help&quot;</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h3 id="不要安装不必要的包"><a href="#不要安装不必要的包" class="header-anchor">#</a> 不要安装不必要的包</h3> <h3 id="解耦应用"><a href="#解耦应用" class="header-anchor">#</a> 解耦应用</h3> <p>一个 docker 容器不应该做太多的事，可以使用多个 docker 容器来分别部署不相关的应用，让他们通过容器网络来交互。</p> <h3 id="对多行参数排序"><a href="#对多行参数排序" class="header-anchor">#</a> 对多行参数排序</h3> <p>举例如下，多个包的名字应该通过 <code>\</code> 来换行，并且和包名称前空一个空格，使得结构看起来更加清晰。</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y \
  bzr \
  cvs \
  git \
  mercurial \
  subversion
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="利用构建缓存"><a href="#利用构建缓存" class="header-anchor">#</a> 利用构建缓存</h3> <p>Dockerfile 在构建时按照其中的指令顺序构建，每次构建都会生成一个中间镜像。下一条指令会根据上一个中间镜像的结果来构建。所以每次检查指令的时候， docker 会寻找是否有镜像缓存可以复用，这样就不需要创建一个新的中间镜像。如果不想使用缓存，可以在构建的时候使用 <code>--no-cache</code>。</p> <p>docker daemnon 通过 Dockerfile 构建镜像时，当发现即将新构建出的镜像与已有的某镜像重复时，可以选择放弃构建新的镜像，而是选用已有的镜像作为构建结果，也就是采取本地已经 cache 的镜像作为结果。</p> <p>缓存的命中规则如下：</p> <ul><li>基本原则是从已在缓存中的父镜像开始，将下一条指令与从该基本镜像派生的所有子映像进行比较，以查看是否其中一个是使用完全相同的指令构建的。如果不是，则缓存无效。</li> <li>对于 <code>ADD</code> 和 <code>COPY</code> 指令，镜像中文件的内容被检查，然后对每个文件计算一个校验和，校验和中不关注上次修改时间和上次访问时间。在检查缓存的时候，将校验和和已有的镜像做比较，如果相等，则使用缓存，如果不相等，该镜像及后续所有的构建缓存全部无效。</li> <li>除却这两个命令的其他命令，缓存都不会通过检查文件来确定缓存是否改变。举个例子，<code>RUN apt-get -y update</code> 这个指令不会通过比较文件变化来确定缓存，仅仅通过比较指令的字符串有没有发生变化来确定是否使用缓存。</li> <li>一旦缓存无效，dockerfile 中后续所有的指令都会生成新的镜像来构建。</li></ul> <h4 id="利用缓存的最佳实践"><a href="#利用缓存的最佳实践" class="header-anchor">#</a> 利用缓存的最佳实践</h4> <p>由于 docker 缓存的机制，要将不长变更的改动放在 Dockerfile 的最前面，比如 <code>RUN apt update</code> 或者 <code>RUN curl xxx</code> 等，同时，针对不同语言，例如 nodejs，应该将 package.json 文件先拷贝进来再执行 <code>npm install</code>，这样当 nodejs 里其他文件变更并不会导致 <code>npm install</code> 的执行，从而加快构建。对于 golang 来说，同样的道理，应该先拷贝 <code>go.mod</code> 和 <code>go.sum</code>，再执行 <code>go mod download</code>, 这样可以有效的缓存安装的依赖，加快构建。</p> <h3 id="不要在-dockerfile-中映射公有端口"><a href="#不要在-dockerfile-中映射公有端口" class="header-anchor">#</a> 不要在 Dockerfile 中映射公有端口</h3> <p>例如下面这种，这样会给应用的部署带来不确定性，应该通过 -p 来在运行时指定。</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code>＃private and public mapping
<span class="token keyword">EXPOSE</span> 80<span class="token punctuation">:</span>8080

＃private only
<span class="token keyword">EXPOSE</span> 80
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="尽量减少镜像大小"><a href="#尽量减少镜像大小" class="header-anchor">#</a> 尽量减少镜像大小</h3> <h3 id="参考-3"><a href="#参考-3" class="header-anchor">#</a> 参考</h3> <ul><li><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="noopener noreferrer">dockerfile-best-practices<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="http://open.daocloud.io/docker-build-de-cache-ji-zhi/" target="_blank" rel="noopener noreferrer">docker cache 机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/25/2020, 4:33:40 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/nodejs/set_interval_no_overlap.html" class="prev">
        如何实现一个不堆叠的 setInterval
      </a></span> <span class="next"><a href="/blog/docker/command.html">
        docker 常用命令
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.2efd3993.js" defer></script><script src="/blog/assets/js/2.371adafa.js" defer></script><script src="/blog/assets/js/23.8248b6b6.js" defer></script>
  </body>
</html>
